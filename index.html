<!doctype html>


<html>

<head>
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <meta name="theme-color" content="#4F7DC9">
    <meta charset="UTF-8">
    <title>TDD for Android</title>
    <script src="bower_components/webcomponentsjs/webcomponents-lite.min.js"></script>
    <link rel="import" href="elements/codelab.html">
    <link rel="stylesheet" type="text/css" href="css/main.css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <style>
        body {
            font-family: "Roboto", sans-serif;
        }
    </style>
    <script type="text/javascript">
        $(document).ready(function() {
            $(function() {
                $.each(document.images, function() {
                    var that = this;
                    var src = $(that).attr('src') || '';
                    if (!src.length > 0) {
                        var fsrc = $(that).attr('fsrc');
                        var img = new Image();
                        img.src = fsrc;
                        $(img).load(function() {
                            that.src = this.src;
                        });
                    }
                });
            });
        });
    </script>
</head>

<body unresolved class="fullbleed">

    <google-codelab title="TDD for Android" environment="web" feedback-link="https://github.com/googlecodelabs/about/issues">

        <google-codelab-step label="What is TDD?" duration="20">
            <p>TDD stand for Test Driven Development. It's a software development process which focuses on writing test.</p>
            <img fsrc="img/tdd_flow.gif" />
            <h2>Test-drivent development cycle:</h2>
            <ol>
                <li>Write a failing test.</li>
                <li>Write the code then run again.</li>
                <li>Refactor code.</li>
                <li>Repeat</li>
            </ol>
            <h2>The advantages of TDD:</h2>
            <ol>
                <li>Increased confidence in developing.</li>
                <li>Better code quality.</li>
                <li>Easy to maintance and expand.</li>
                <li>Reduce manual testing.</li>
                <li>Easy to detect an incorrect implmentation.</li>
            </ol>
            <p>But TDD is hard to implement, and it doesn't show its impact in initial stage. You only see it's true value when you have to refactor the code or expand it.</p>
        </google-codelab-step>
        <google-codelab-step label="TDD in Android" duration="20">
            <h2>Type of testing in Android</h2>
            <h3>Unit Test</h3>
            <h4><b>Local Unit Test</b></h4>
            <p>Unit tests that run locally on the Java Virtual Machine, and it doesn't require Android framework dependencies like Context, parcelable</p>
            <h4><b>Instrumentatin Unit Tests</b></h4>
            <p>Unit test that run on an Android emulator or real device. These tests have access to Instrumentation information, such as Context. You can use these tests if your tests have Android dependencies that can not mock or mock object cannot satisfy.</p>
            <p><i>Instrumentation is an Android framework component that provides additional monitoring and control over the application androd test.</i></p>
            <p><i>Tools used for Unit Test:</i></p>
            <ul>
                <li>JUnit: JUnit is a simple framework to write repeatable tests. It is an instance of the xUnit architecture for unit testing frameworks.</li>
                <li>Robolectric: Robolectric is a unit test framework that allow to run your tests inside the JVM.</li>
                <li>Mockito: Mockito is a mocking framework that lets you write beautiful tests with a clean & simple API.</li>
            </ul>
            <h3><b>Intergration Tests</b></h3>
            <h4><b>Components within your app only</b></h4>
            <p>This type of test verifies that the target app behaves as expected when a user performs a specific action or enters a specific input in its activities.</p>
            <h4><b>Cross-app Components</b></h4>
            <p><i>Tools used for Intergration Test:</i></p>
            <ul>
                <li>Espresso: Espresso is a UI test framework that allows you to create automated UI tests for your Android app</li>
                <li>UIAutomator: UIAutomator is and Android UI Testing Frameowk for testing across multiple apps. </li>
                <li>Appium: Appium is an open source test automation framework for use with native, hybrid and mobile web apps.</li>
                <li>Robotium: Robotium provide black box tests for Android applications.</li>
            </ul>
            <p>This type of test verifies the correct behavior of interactions between different user apps or between user apps and system apps</p>
            <h2>How to apply TDD in Android</h2>
            <p>TDD in Android is challenging due to the limitations of its testing instrumentation framework. But it can be made easier by designing application in a way which support TDD, such as <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter">Model-View-Presenter(MVP)</a>,
                <a href="https://en.wikipedia.org/wiki/Model–view–viewmodel">Model-View-ViewModel(MVVM)</a>.</p>
            <p>We'll choose MVP for this tutorial.</p>
            <p>Model-View-Presenter is a derivation of the model-view-controller architecture pattern.</p>
            <ul>
                <li>Model is typically POJO, it defines the data to be displayed or acted upon in the user interface.</li>
                <li>View is passive interface that displays data.It doesn't know anything about business logic.</li>
                <li>Presenter is a middle-man between View and Model, it decides presentation logic, get data from repository and format it to display in View.</li>
            </ul>
        </google-codelab-step>
        <google-codelab-step label="Unit Test">
            <h2>Unit Test</h2>
            <p>Unit test are the most basic type of tests, Each invidual modules are tested to determine if there are any issues by the developer. Unit tests verify the correctness of the smallest units of your code, such as methods, and classes in isolation
                from the codebase. </p>
            <h2>Android Unit Test</h2>
            <p>Unit test should be isolate from the codebase, or even the platform. Any unit tests which don't require Android Framework are put under <code>src/test/.</code></p>
            <p>But if you have an object and its method are depend on some other object, you can create a mock of dependency object instead of creating actual instance of that dependency. If your test needs to interact with Android depdencies, you can use
                mocking framework to simplify your unit test. There are several mocking framework, such as: <a href="http://site.mockito.org/">Mockito</a>,
                <a href="http://easymock.org/">EasyMock</a>.</p>
            <p>Your local unit test should be written as a JUnit 4 test class. To create a basic JUnit 4 test class. create a Java class contains one or more test method. A test method begins with <code>@Test</code> anotataion.</p>
            <p>If you create a new Android Project by using Android Studio, the following Unit test is included.</p>
            <pre><code>
public class ExampleUnitTest {
    @Test
    public void addition_isCorrect() throws Exception {
        assertEquals(4, 2 + 2);
    }
}</code></pre>
            <p>Mock Android dependencies</p>
            <ol>
                <li>Add mockito library to build.gradle</li>
                <pre><code>testCompile 'org.mockito:mockito-core:1.10.19'</code></pre>
                <li>Add the following anotation at the beginning of your test class.</li>
                <pre><code>@RunWith(MockitoJUnitRunner.class)</code></pre>
                <li>To create a mock object, add the <code>@Mock</code> annotation before the field declaration.</li>
                <li>To stub the behavior of the mocked object, You can specify a condition and return value by using <code>when()</code> and <code>thenReturn()</code>.</li>
            </ol>
            <h2>Instrumented unit tests</h2>
            <p>If your test need to access to Instrumentation information, and mock objects can't sastify. You need to create an instrumented unit tests.All Instrumented tests are placed under <code>src/androidTest/</code></p>
        </google-codelab-step>
        <google-codelab-step label="Intergration Test">
            <h2>Automating UI Tests</h2>
            <p>UI testing lets you ensure the quality and functional requirements. There're two approach to UI testing: manual testing and automated testing.</p>
            <p>To automate UI tests with Android Studio, you must implement your test in a seperate folder (<code>src/androidTest/java</code>).</p>
            <p>If you want to test on your app only, you can use Espresso. To verify the behavior between different apps or between your app and system app, you can use UI Automator. Appium is an another solution.</p>
            <h2>Testing App Components</h2>
            <p>If you want to test components that do not have an ui, such as ContentProvide or Service. You must create your test class with <code>ProviderTestCase2</code> or <code>ServiceTestRule</code>.</p>
        </google-codelab-step>
        <google-codelab-step label="Project setup">
            <p>We will use the following API as remote data: <a href="https://jsonplaceholder.typicode.com/">JSONPlaceHolder</a>.</p>
            <ul>
                <li><a href="https://jsonplaceholder.typicode.com/users">/users</a></li>
                <li><a href="https://jsonplaceholder.typicode.com/comments?userId=1">/comments?userId=1</a></li>
                <li><a href="https://jsonplaceholder.typicode.com/photos?userId=1">/photos?userId=1</a></li>
            </ul>
            <p>The Wireframe will look like this:</p>
            <img fsrc="img/wireframe.jpeg" />
            <p>Comments and photos will be persisted by <a href="https://realm.io/">Realm</a>. Others libraries will be used are: Dagger2, Retrofit2,RxAndroid.</p>
            <p>Project structure will look like this:</p>
            <table>
                <tbody>
                    <tr>
                        <td colspan="2" rowspan="1">
                            <p><strong>Package: </strong><code>com.example.androidtdd</code></p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>.data</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>"Data": Storage of application - this contains the model layer</p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>.data.remote</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>"Remote Data Source": Get data from remote source</p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>.data.local</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>"Local Data Source ": Get data from local storage</p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>.data.model</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>"Model": This contains the object model</p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>.di</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>Dependency Injection</p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>.ui.base</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>"Base": Base package to implement MVP</p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>.ui.home</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>"home": Showing a list of all users</p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>.ui.detail</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>Detail: Show more about user's information.</p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>.ui.comment</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>Showing a list of comments from a specific user.</p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>.ui.photo</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>Showing a list of photos from a specific user.</p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>.util</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>Utility classes used in various parts of the app.</p>
                        </td>
                    </tr>
                </tbody>
            </table>
            <p>Let's get started by create a new project.</p>
            <img fsrc="img/newproject.png" />
            <p>Add the following dependencies, we'll add more later</p>
            <code>dependencies.gradle</code>
            <pre><code>ext{
    supportLibraryVersion = "25.1.0"
    retrofitVersion = "2.1.0"
    okhttpVersion = "3.5.0"
    rxAndroidVersion = "1.2.1"
    butterKnifeVersion = "8.4.0"
    mockitoVersion = "1.10.19"
    daggerVersion = "2.8"
    robolectricVersion = "3.0"
    powermockVersion = "1.6.6"
    androidSupportTestRunner = "0.5"
    espressoVersion = "2.2.2"
    daggerMockVersion = "0.6.2"
    dexMakerVersion = "1.2"
    glideVersion = "3.7.0"
}</code></pre>
            <code>build.gradle</code> project level
            <pre><code>buildscript {
    apply from: 'dependencies.gradle'
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:2.2.3'
        classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'
        classpath "io.realm:realm-gradle-plugin:2.2.1"
        classpath 'me.tatarka:gradle-retrolambda:3.4.0'
    }
}</code></pre>
            <code>build.gradle</code> module level
            <pre><code>apply plugin: 'com.android.application'
apply plugin: 'me.tatarka.retrolambda'
apply plugin: 'com.neenbedankt.android-apt'
apply plugin: 'realm-android'
android{
    ...
    compileOptions {
        targetCompatibility 1.8
        sourceCompatibility 1.8
    }
}
dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile "com.android.support:appcompat-v7:${supportLibraryVersion}"
    compile "com.android.support:design:${supportLibraryVersion}"
    compile "com.android.support:cardview-v7:${supportLibraryVersion}"

    // Dagger2 dependencies
    apt "com.google.dagger:dagger-compiler:${daggerVersion}"
    compile "com.google.dagger:dagger:${daggerVersion}"
    provided "javax.annotation:jsr250-api:1.0"

    // Setup Retrofit
    compile "com.squareup.retrofit2:retrofit:${retrofitVersion}"
    compile "com.squareup.retrofit2:converter-gson:${retrofitVersion}"
    compile "com.squareup.retrofit2:adapter-rxjava:${retrofitVersion}"
    compile "com.squareup.okhttp3:logging-interceptor:${okhttpVersion}"

    // ButterKnife setup
    compile "com.jakewharton:butterknife:${butterKnifeVersion}"
    apt "com.jakewharton:butterknife-compiler:${butterKnifeVersion}"

    compile "com.github.bumptech.glide:glide:${glideVersion}"
    
    // RxAndroid
    compile "io.reactivex:rxandroid:${rxAndroidVersion}"

    testCompile 'junit:junit:4.12'

    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
        exclude group: 'com.android.support', module: 'support-annotations'
    })
}
</code></pre>
        </google-codelab-step>
        <google-codelab-step label="Data Package">
            <p>Let's get started by create a object model base on API</p>
            <p>First, create object model base on API:</p>
            <code>User</code>
            <pre><code>
public class User implements Parcelable {
    private int id;
    private String name;
    private String email;
    private String phone;
    private String website;
    private Address address;
    private Company company;
    ...
}</code></pre>
            <code>Address</code>
            <pre><code>
public class Address implements Parcelable {
    private String street;
    private String suite;
    private String city;
    private String zipcode;
    ....
}</code></pre>
            <code>Company</code>
            <pre><code>
public class Company implements Parcelable {
    private String catchPhrase;
    private String name;
    private String bs;
    ...
}</code></pre>
            <code>Photo</code>
            <pre><code>
public class Photo extends RealmObject implements Parcelable {
    @PrimaryKey
    private int id;
    private int userId;
    private int albumId;
    private String title;
    private String url;
    private String thumbnailUrl;
    ...
}</code></pre>
            <code>Comment</code>
            <pre><code>
public class Comment extends RealmObject implements Parcelable {
    @PrimaryKey
    private int id;
    private int userId;
    private int postId;
    private String name;
    private String email;
    private String body;
    ...
}</code></pre>
            <h2>Prepare Mock data</h2>
            <p>Create a <code>sharedTest</code> folder in <code>app/src/</code>, and two sub folders: <code>java</code>,<code>resources</code>.</p>
            <p>Add the following line to <code>build.gradle</code>:</p>
            <pre><code>...
android{
    sourceSets {
        String sharedTestDir = 'src/sharedTest/java'
        String sharedResourceDir = 'src/sharedTest/resources'
        test {
            java.srcDir sharedTestDir
            resources.srcDirs += sharedResourceDir
        }
        androidTest {
            java.srcDir sharedTestDir
            resources.srcDirs += sharedResourceDir

        }
    }
}
...</code></pre>
            <p>Save the following file to <code>sharedTest/resources</code>:
                <a href="/json/users.json">users.json</a>,
                <a href="/json/comments.json">comments.json</a>,
                <a href="/json/photos.json">photos.json</a>.
            </p>
            <p>Create <code>MockHelper.java</code> under <code>sharedTest/java/com/example/androidtdd</code></p>
            <pre><code>
package com.example.androidtdd;

import com.example.androidtdd.data.model.Address;
import com.example.androidtdd.data.model.Comment;
import com.example.androidtdd.data.model.Company;
import com.example.androidtdd.data.model.Photo;
import com.example.androidtdd.data.model.User;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * Created by quanlt on 25/01/2017.
 */

public class MockHelper {
    private static Address makeAddress() {
        Address address = new Address();
        address.setCity("Gwenborough");
        address.setSuite("Apt. 556");
        address.setStreet("Kulas Light");
        return address;
    }

    private static Company makeCompany() {
        Company company = new Company();
        company.setBs("Romaguera-Crona");
        company.setCatchPhrase("Multi-layered client-server neural-net");
        company.setName("Romaguera-Crona");
        return company;
    }

    public static User makeUser(int userId) {
        User user = new User();
        user.setId(userId);
        user.setName("Leanne Graham");
        user.setEmail("Sincere@april.biz");
        user.setAddress(makeAddress());
        user.setCompany(makeCompany());
        user.setPhone("1-770-736-8031");
        user.setWebsite("hildegard.org");
        return user;
    }

    public static String readUsersString() throws IOException {
        InputStream stream = MockHelper.class.getClassLoader().getResourceAsStream("users.json");
        Scanner s = new Scanner(stream).useDelimiter("\\A");
        String result = s.hasNext() ? s.next() : "";
        stream.close();
        return result;
    }

    public static String readPhotosString() throws IOException {
        InputStream stream = MockHelper.class.getClassLoader().getResourceAsStream("photos.json");
        Scanner s = new Scanner(stream).useDelimiter("\\A");
        String result = s.hasNext() ? s.next() : "";
        stream.close();
        return result;
    }

    public static String readCommentsString() throws IOException {
        InputStream stream = MockHelper.class.getClassLoader().getResourceAsStream("comments.json");
        Scanner s = new Scanner(stream).useDelimiter("\\A");
        String result = s.hasNext() ? s.next() : "";
        stream.close();
        return result;
    }

    public static List&lt;User&gt; getUsers(String json, Gson gson) {
        Type userType = new TypeToken&lt;ArrayList&lt;User&gt;&gt;() {
        }.getType();
        return gson.fromJson(json, userType);
    }

    public static List&lt;Comment&gt; getPhotos(String json, Gson gson) {
        Type photoType = new TypeToken&lt;ArrayList&lt;Photo&gt;&gt;() {
        }.getType();
        return gson.fromJson(json, photoType);
    }

    public static List&lt;Comment&gt; getComments(String json, Gson gson) {
        Type commentType = new TypeToken&lt;ArrayList&lt;Comment&gt;&gt;() {
        }.getType();
        return gson.fromJson(json, commentType);
    }

    public static List&lt;Comment&gt; getPhotos() throws IOException {
        return getPhotos(readPhotosString(), new Gson());
    }

    public static List&lt;Comment&gt; getComments() throws IOException {
        return getComments(readCommentsString(), new Gson());
    }

    public static List&lt;User&gt; getUsers() throws IOException {
        return getUsers(readUsersString(), new Gson());
    }
}</code></pre>

            <h2>Remote data</h2>
            <p>Remote data have the following class and interface:</p>
            <table>
                <tbody>
                    <tr>
                        <td colspan="2" rowspan="1">
                            <p><strong>Package: </strong><code>com.example.androidtdd.data.remote</code></p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>ApiService</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>Interface for Retrofit and Retrofit Creator.</p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>RemoteDataSource</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>Interface for RemoteData.</p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>RemoteDataSourceImpl</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>RemoteData's implementation.</p>
                        </td>
                    </tr>
                </tbody>
            </table>
            <code>ApiService.java</code>
            <pre><code>
public interface ApiService {
    @GET("users")
    Observable&lt;List&lt;User&gt;&gt; getUsers();

    @GET("posts")
    Observable&lt;List&lt;Comment&gt;&gt; getPost(@Query("userId") int userId);

    @GET("photos")
    Observable&lt;List&lt;Photo&gt;&gt; getPhotos(@Query("userId") int userId);
    class Creator {

        public static Retrofit newRetrofitInstance() {
            HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();
            interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);
            OkHttpClient client = new OkHttpClient.Builder()
                    .addInterceptor(interceptor)
                    .build();


            return new Retrofit.Builder()
                    .baseUrl(Constants.ENDPOINT)
                    .addConverterFactory(GsonConverterFactory.create())
                    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
                    .client(client)
                    .build();

        }

    }
}</code></pre>
            <code>RemoteDataSource.java</code>
            <pre><code>public interface RemoteDataSource {

    Observable&lt;List&lt;User&gt;&gt; getUsers();
    
    Observable&lt;List&lt;Comment&gt;&gt; getComments(int userId);

    Observable&lt;List&lt;Photo&gt;&gt; getPhotos(int userId);
}
</code></pre>
            <code>RemoteDataSourceImpl.java</code> will do nothing but call <code>ApiService</code> and return its result.
            <pre><code>public class RemoteDataSourceImpl implements RemoteDataSource {
    private ApiService mApiService;

    public RemoteDataSourceImpl(ApiService mApiService) {
        this.mApiService = mApiService;
    }

    @Override
    public Observable&lt;List&lt;User&gt;&gt; getUsers() {
        return null;
    }

    @Override
    public Observable&lt;List&lt;Comment&gt;&gt; getComments(int userId) {
        return null;
    }

    @Override
    public Observable&lt;List&lt;Photo&gt;&gt; getPhotos(int userId) {
        return null;
    }
}
</code></pre>
            <p>Create a <code>RemoteDataSourceImpl</code> test:</p>
            <pre><code>
//src/test/com/example/androidtdd/data/remote
@RunWith(MockitoJUnitRunner.class)
public class RemoteDataSourceImplTest {
    @Mock
    ApiService mMockApiService;
    private RemoteDataSource mRemoteDataSource;

    @Before
    public void setUp() throws Exception {
        mRemoteDataSource = new RemoteDataSourceImpl(mMockApiService);
    }

    @Test
    public void testGetUsers() throws Exception {
        mRemoteDataSource.getUsers();
        verify(mMockApiService, times(1)).getUsers();
    }
}
</code></pre>
            <p>This test will fail</p>
            <pre><code>
Wanted but not invoked:
mMockApiService.getUsers();
-> at com.example.androidtdd.data.remote.RemoteDataSourceImplTest.testGetUsers(RemoteDataSourceImplTest.java:32)
Actually, there were zero interactions with this mock.
</code></pre>
            <p>Let's implement getUsers in <code>RemoteDataSourceImpl</code>.</p>
            <pre><code>@Override
public Observable&lt;List&lt;User&gt;&gt; getUsers() {
    return mApiService.getUsers();
}</code></pre>
            <p>Then run <code>RemoteDataSourceImpl</code> again</p>
            <img fsrc="img/test-get-users.png" style="max-width: 361px;" />
            <p>Nothing to refactor, keep moving</p>
            <p>If <i>RemoteDataSource</i> has any problem, an exception should be thrown, it's a feature of RxJava, but we'll test it anyway.</p>
            <pre><code>@Test(expected = Exception.class)
public void testGetUsersFailed() throws Exception {
    when(mRemoteDataSource.getUsers())
            .thenReturn(Observable.error(new Throwable("Error")));
    mRemoteDataSource.getUsers().toBlocking().first();
}</code></pre>

            <p><code>getPhotos(int userId)</code> and <code>getComments(int userId)</code> are similar to <code>getUsers()</code></p>
            <img fsrc="img/test-remote-datasource.png" style="max-width: 361px;" />
            <p>We'll use <code>MockWebServer</code> to test our <code>RemoteDataSourceImpl</code> with server:</p>
            <p>Add the following dependency to <code>build.gradle</code></p>
            <pre><code>
...
dependencies{
    ...
    testCompile "com.squareup.okhttp3:mockwebserver:${okhttpVersion}"
    androidTestCompile "com.squareup.okhttp3:mockwebserver:${okhttpVersion}"
    ...
}
</code></pre>
            <code>RemoteDataSourceImplWithMockServerTest</code>
            <pre><code>
@RunWith(MockitoJUnitRunner.class)
public class RemoteDataSourceImplWithMockServerTest {
    private RemoteDataSource mRemoteDataSource;
    private final int USER_ID = 10;
    private MockWebServer server = new MockWebServer();

    @Before
    public void setUp() throws Exception {
        String url = server.url("/").toString();
        HttpLoggingInterceptor interceptor = new HttpLoggingInterceptor();
        interceptor.setLevel(HttpLoggingInterceptor.Level.BODY);
        OkHttpClient client = new OkHttpClient.Builder()
                .addInterceptor(interceptor)
                .build();
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(url)
                .addConverterFactory(GsonConverterFactory.create())
                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
                .client(client)
                .build();
        ApiService apiService = retrofit.create(ApiService.class);
        mRemoteDataSource = new RemoteDataSourceImpl(apiService);
    }
    @After
    public void tearDown() throws Exception {
        server.shutdown();
    }
}</code></pre>
            <p>If you use Emulator to run MockWebServer, you should check <code>hosts</code> file under <code>/etc/hosts</code> in your emulator. It should contains <code>127.0.0.1       localhost</code>.</p>
            <p>Thank retrofit and gson, we don't have to do anything, everything works well</p>
            <pre><code>@Test
public void testGetUsersSuccess() throws Exception {
    String usersString = MockHelper.readUsersString();
    server.enqueue(new MockResponse().setBody(MockHelper.readUsersString()));
    Observable&lt;List&lt;User&gt;&gt; result = mRemoteDataSource.getUsers();
    List&lt;User&gt; actual = result.toBlocking().first();
    List&lt;User&gt; expected = MockHelper.getUsers(usersString, new Gson());
    assertEquals(expected.get(0), actual.get(0));
}
@Test(expected = RuntimeException.class)
public void testGetUserFail() {
    server.enqueue(new MockResponse().setResponseCode(404).setBody("Generic Error"));
    Observable result = mRemoteDataSource.getUsers();
    result.toBlocking().first();
}</code></pre>
            <p><code>getPhotos</code> and <code>getComments</code> are similar.</p>
            <p>To learn more about MockWebServer, click <a href="https://github.com/square/okhttp/tree/master/mockwebserver">here</a>.</p>
            <h2>Local data</h2>
            <p>Local data has the following classes and interfaces:</p>
            <table>
                <tbody>
                    <tr>
                        <td colspan="2" rowspan="1">
                            <p><strong>Package: </strong><code>com.example.androidtdd.data.local</code></p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>LocalDataSource</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>Interface for LocalData.</p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>LocalDataSourceImpl</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>LocalDataSource's implementation.</p>
                        </td>
                    </tr>
                </tbody>
            </table>

            <code>LocalDataSource</code>
            <pre><code>
public interface LocalDataSource {
    void saveComment(List&lt;Comment> comments, int userId);

    void savePhoto(List&lt;Photo> photos, int userId);

    Observable&lt;List&lt;Comment&gt;&gt; getComments(int userId);

    Observable&lt;List&lt;Photo&gt;&gt; getPhotos(int userId);
}
</code></pre>
            <code>LocalDataSourceImpl</code>
            <pre><code>
public class LocalDataSourceImpl implements LocalDataSource {

    public LocalDataSourceImpl() {
    }

    @Override
    public void saveComment(List&lt;Comment> comments, int userId) {

    }

    @Override
    public void savePhoto(List&lt;Photo> photos, int userId) {

    }

    @Override
    public Observable&lt;List&lt;Comment&gt;&gt; getComments(int userId) {
        return null;
    }

    @Override
    public Observable&lt;List&lt;Photo&gt;&gt; getPhotos(int userId) {
        return null;

    }
}
</code></pre>
            <p>Local data is more complicated than remote data since it depends on Realm, we'll use robolectric, powermock to run our test without emulator or real device.</p>
            <p>Add the following dependencies to <code>build.gradle</code>:</p>
            <pre><code>
testCompile "org.robolectric:robolectric:${robolectricVersion}"
testCompile "org.powermock:powermock-module-junit4:${powermockVersion}"
testCompile "org.powermock:powermock-module-junit4-rule:${powermockVersion}"
testCompile "org.powermock:powermock-api-mockito:${powermockVersion}"
testCompile "org.powermock:powermock-classloading-xstream:${powermockVersion}"</code></pre>
            <p>Initial of <code>LocalDataSourceImplTest</code></p>
            <pre><code>@RunWith(RobolectricTestRunner.class)
@Config(constants = BuildConfig.class)
@PowerMockIgnore({"org.mockito.*", "org.robolectric.*", "android.*"})
@SuppressStaticInitializationFor("io.realm.internal.Util")
@PrepareForTest({Realm.class, RealmLog.class})
public class LocalDataSourceImplTest {
    Realm mMockRealm;
    @Rule
    public PowerMockRule rule = new PowerMockRule();
    private LocalDataSource mLocalDataSource;

    @Before
    public void setUp() throws Exception {
        mockStatic(RealmLog.class);
        mockStatic(Realm.class);
        mMockRealm = mock(Realm.class);
        when(Realm.getDefaultInstance()).thenReturn(mMockRealm);
        List&lt;Comment&gt; comments = MockHelper.getComments();
        List&lt;Photo&gt; photos = MockHelper.getPhotos();

        RealmQuery&lt;Comment&gt; commentQuery = mock(RealmQuery.class);
        RealmQuery&lt;Photo&gt; photoQuery = mock(RealmQuery.class);

        RealmResults commentResult = mock(RealmResults.class);
        RealmResults photoResult = mock(RealmResults.class);

        when(mMockRealm.where(Comment.class)).thenReturn(commentQuery);
        when(mMockRealm.where(Photo.class)).thenReturn(photoQuery);

        when(commentQuery.findAll()).thenReturn(commentResult);
        when(photoQuery.findAll()).thenReturn(photoResult);

        when(commentQuery.equalTo("userId", USER_ID)).thenReturn(commentQuery);
        when(photoQuery.equalTo("userId", USER_ID)).thenReturn(photoQuery);

        doCallRealMethod().when(mMockRealm)
                .executeTransaction(Mockito.any(Realm.Transaction.class));
        when(commentResult.iterator()).thenReturn(comments.iterator());
        when(photoResult.iterator()).thenReturn(photos.iterator());

        mLocalDataSource = new LocalDataSourceImpl();
    }

    @Test
    public void testGetInstance() throws Exception {
        assertEquals(Realm.getDefaultInstance(), mMockRealm);
    }
    
}</code></pre>
            <p>First, test save comment method</p>
            <pre><code>@Test
public void testSaveComments() throws Exception {
    doCallRealMethod().when(mMockRealm).executeTransaction(Mockito.any(Realm.Transaction.class));
    int userId = 2;
    List comments = DataFactory.makeComments(userId);
    mLocalDataSource.saveComment(comments, userId);
    verify(mMockRealm, times(1)).copyToRealmOrUpdate(comments);
    verify(mMockRealm, times(1)).close();
}</code></pre>
            <p>And run the test</p>
            <pre><code>Wanted but not invoked:
realm.copyToRealmOrUpdate(
    [com.example.androidtdd.data.model.Comment@77b21474, com.example.androidtdd.data.model.Comment@52d10fb8, com.example.androidtdd.data.model.Comment@41c07648, com.example.androidtdd.data.model.Comment@1fe8d51b, com.example.androidtdd.data.model.Comment@781e7326, com.example.androidtdd.data.model.Comment@22680f52, com.example.androidtdd.data.model.Comment@60d84f61]
);
-> at com.example.androidtdd.data.local.LocalDataSourceImplTest.testSaveComments(LocalDataSourceImplTest.java:65)
Actually, there were zero interactions with this mock.

Wanted but not invoked:
realm.copyToRealmOrUpdate(
    [com.example.androidtdd.data.model.Comment@77b21474, com.example.androidtdd.data.model.Comment@52d10fb8, com.example.androidtdd.data.model.Comment@41c07648, com.example.androidtdd.data.model.Comment@1fe8d51b, com.example.androidtdd.data.model.Comment@781e7326, com.example.androidtdd.data.model.Comment@22680f52, com.example.androidtdd.data.model.Comment@60d84f61]
);
-> at com.example.androidtdd.data.local.LocalDataSourceImplTest.testSaveComments(LocalDataSourceImplTest.java:65)
Actually, there were zero interactions with this mock.</code></pre>
            <p>Let's implement <code>saveComment</code></p>
            <pre><code>@Override
public void saveComment(List&lt;Comment> comments, int userId) {
    for (Comment comment : comments) {
        comment.setUserId(userId);
    }
    Realm bgRealm = Realm.getDefaultInstance();
    bgRealm.executeTransaction(realm -> realm.copyToRealmOrUpdate(comments));
    bgRealm.close();
}</code></pre>
            <p>similar to <code>savePhoto</code>.</p>
            <code>LocalDataSourceImplTest</code>
            <pre><code>@Test
public void testSavePhotos() throws Exception {
    List photos = DataFactory.makePhotos(USER_ID);
    mLocalDataSource.savePhotos(photos, USER_ID);
    verify(mMockRealm, times(1)).copyToRealmOrUpdate(photos);
    verify(mMockRealm,times(1)).close();
}</code></pre>
            <code>LocalDataSourceImpl</code>
            <pre><code>Realm bgRealm = Realm.getDefaultInstance();
    for (Photo photo : photos) {
        photo.setUserId(userId);
    }
    bgRealm.executeTransaction(realm -> realm.copyToRealmOrUpdate(photos));
    bgRealm.close();
}</code></pre>
            <p>The next one is <code>getComments</code>, We'll take comment from local storage which its userId equals to the given userId</p>
            <code>LocalDataSourceImplTest</code>
            <pre><code>@Test
public void testGetComments() throws Exception {
    mLocalDataSource.getComments(USER_ID);
    verify(mMockRealm.where(Comment.class).equalTo("userId", USER_ID)).findAll();
    verify(mMockRealm).close();
}</code></pre>
            <p> Sice we haven't implemented LocalDataSourceImpl yet, this test will fail</p>
            <pre><code>Wanted but not invoked:
realmQuery.findAll();
-> at com.example.androidtdd.data.local.LocalDataSourceImplTest.testGetComments(LocalDataSourceImplTest.java:108)

However, there were other interactions with this mock:
realmQuery.equalTo("userId", 2);
-> at com.example.androidtdd.data.local.LocalDataSourceImplTest.testGetComments(LocalDataSourceImplTest.java:108)</code></pre>
            <p><code>getComments</code>'s implementation</p>
            <pre><code>@Override
public Observable&lt;List&lt;Comment&gt;&gt; getComments(int userId) {
    Realm bgRealm = Realm.getDefaultInstance();
    List&lt;Comment> comments = bgRealm
            .where(Comment.class)
            .equalTo("userId", userId)
            .findAll();
    bgRealm.close();
    return Observable.just(comments);
}</code></pre>
            <p>And run <code>testGetComments</code> again, This time, it is green. But we dont want to track data with Realm, so <code>copyFromRealm</code> should be called.</p>
            <pre><code>@Test
public void testGetComments() throws Exception {
    ...
    verify(mMockRealm).copyFromRealm(any(Iterable.class));
    verify(mMockRealm).close();
}</code></pre>
            <p>No wonder that <code>testGetComments</code> will fail</p>
            <pre><code>Wanted but not invoked:
realm.copyFromRealm(null);
-> at com.example.androidtdd.data.local.LocalDataSourceImplTest.testGetComments(LocalDataSourceImplTest.java:109)</code></pre>
            <p>we'll add <code>copyFromRealm</code> to <code>getComments</code></p>
            <pre><code>@Override
    public Observable&lt;List&lt;Comment&gt;&gt; getComments(int userId) {
        ...
        if (comments != null) {
            comments = bgRealm.copyFromRealm(comments);
        }
        bgRealm.close();
        return Observable.just(comments);
    }</code></pre>
            <p>Similar to <code>getPhotos</code></p>
            <pre><code>@Override
public Observable&lt;List&lt;Photo&gt;&gt; getPhotos(int userId) {
    Realm bgRealm = Realm.getDefaultInstance();
    List&lt;Photo> photos = bgRealm
            .where(Photo.class)
            .equalTo("userId", userId)
            .findAll();
    if (photos != null) {
        photos = bgRealm.copyFromRealm(photos);
    }
    bgRealm.close();
    return Observable.just(photos);
}</code></pre>
            <h2>Repository</h2>
            <p>Repository have the following class and interface:</p>
            <table>
                <tbody>
                    <tr>
                        <td colspan="2" rowspan="1">
                            <p><strong>Package: </strong><code>com.example.androidtdd.data.remote</code></p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>PlaceHolderRepository</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>Interface to access data.</p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>RemoteDataSource</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>An implmentation of PlaceHolderRepository.</p>
                        </td>
                    </tr>
                </tbody>
            </table>
            <code>PlaceHolderRepository</code>
            <pre><code>public interface PlaceHolderRepository {
    Observable&lt;List&lt;User&gt;&gt; getUsers();

    Observable&lt;List&lt;Comment&gt;&gt; getComments(int userId);

    Observable&lt;List&lt;Photo&gt;&gt; getPhotos(int userId);
}</code></pre>
            <code>PlaceHolderRepositoryImpl</code>
            <pre><code>public class LocalDataSourceImpl implements LocalDataSource {

    private LocalDataSource mLocalDataSource;
    private RemoteDataSource mRemoteDataSource;

    public PlaceHolderRepositoryImpl(LocalDataSource mLocalDataSource, RemoteDataSource mRemoteDataSource) {
        this.mLocalDataSource = mLocalDataSource;
        this.mRemoteDataSource = mRemoteDataSource;
    }

    @Override
    public void saveComment(List&lt;Comment> comments, int userId) {

    }

    @Override
    public void savePhoto(List&lt;Photo> photos, int userId) {


    }

    @Override
    public Observable&lt;List&lt;Comment&gt;&gt; getComments(int userId) {
        return null;
    }

    @Override
    public Observable&lt;List&lt;Photo&gt;&gt; getPhotos(int userId) {
        return null;

    }
}</code></pre>
            <code>getComments</code> will get comment with the following restrictions:
            <ul>
                <li>If local comments are available, load from device.</li>
                <li>If local comments are not available, load from server.</li>
                <li>If comments are loaded from server, it must be saved to device.</li>
            </ul>
            <code>PlaceHolderRepositoryImplTest</code>
            <pre><code>
@RunWith(PowerMockRunner.class)
@PrepareForTest(Uri.class)
public class PlaceHolderRepositoryImplTest {
    @Mock
    private LocalDataSource mMockLocalDataSource;
    @Mock
    private RemoteDataSource mMockRemoteDataSource;
    private PlaceHolderRepository mPlaceHolderRepository;
    private int USER_ID = 10;

    private TestSubscriber<List<Comment>> commentsTestSubscriber = new TestSubscriber<>();
    private TestSubscriber<List<Photo>> photosTestSubscriber = new TestSubscriber<>();
    private TestSubscriber<List<User>> usersTestSubscriber = new TestSubscriber<>();

    @Before
    public void setUp() throws Exception {
        mPlaceHolderRepository = new PlaceHolderRepositoryImpl(mMockLocalDataSource, mMockRemoteDataSource);
        PowerMockito.mockStatic(Uri.class);
        Uri uri = mock(Uri.class);
        PowerMockito.when(Uri.class, "parse", anyString()).thenReturn(uri);
    }
    @Test
    public void testGetCommentsFromServer() throws Exception {
        List&lt;Comment> comments = DataFactory.makeComments(USER_ID);
        when(mMockLocalDataSource.getComments(USER_ID))
                .thenReturn(Observable.error(new Throwable()));
        when(mMockRemoteDataSource.getComments(USER_ID))
                .thenReturn(Observable.just(comments));
        mRepository.getComments(USER_ID).subscribe(commentTestSubscriber);
        verify(mMockRemoteDataSource).getComments(USER_ID);
        commentTestSubscriber.assertNoErrors();
        commentTestSubscriber.assertCompleted();
        commentTestSubscriber.assertValue(comments);
    }
}</code></pre>
            <p>Since <code>getComments</code> returns <code>null</code>, we have this log</p>
            <pre><code>java.lang.NullPointerException
	at com.example.androidtdd.data.PlaceHolderRepositoryImplTest.testGetCommentsFromServer(PlaceHolderRepositoryImplTest.java:52)</code></pre>
            <p>In <code>getComments</code>, replace <code>return null;</code> by <code>return Observable.empty();</code>, and run again.</p>
            <pre><code>java.lang.AssertionError: Number of items does not match. Provided: 1  Actual: 0.
Provided values: [[com.example.androidtdd.data.model.Comment@394e1a0f,...]]
Actual values: []
 (1 completion)</code></pre>
            <p>Let's implement <code>getComments</code>, so we'll get data from server</p>
            <pre><code>@Override
public Observable&lt;List&lt;Comment&gt;&gt; getComments(int userId) {
    return mRemoteDataSource.getComments(userId);
}</code></pre>
            <p>It's green now, we'll create another test method to get data from local.</p>
            <pre><code>@Test
public void testGetCommentsFromLocal() throws Exception {
    List&lt;Comment> comments = DataFactory.makeComments(USER_ID);
    when(mMockLocalDataSource.getComments(USER_ID))
            .thenReturn(Observable.just(comments));
    when(mMockRemoteDataSource.getComments(USER_ID))
            .thenReturn(Observable.empty());
    mRepository.getComments(USER_ID).subscribe(commentTestSubscriber);
    verify(mMockLocalDataSource).getComments(USER_ID);
    commentTestSubscriber.assertNoErrors();
    commentTestSubscriber.assertCompleted();
    commentTestSubscriber.assertValue(comments);
}</code></pre>
            <p>We must implement <code>getComments</code> to get data from local. We'll use <code>Observable.concat(...)</code>.</p>
            <pre><code>@Override
    public Observable&lt;List&lt;Comment&gt;&gt; getComments(int userId) {
        return Observable.concat(mLocalDataSource.getComments(userId),
                mRemoteDataSource.getComments(userId));
    }</code></pre>
            <p><img fsrc="img/test-fail.png" class="test-result"><code>PlaceHolderRepositoryImpl</code></p>
            <p><img fsrc="img/test-fail.png" class="test-result level-1"><code>testGetCommentsFromServer</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testGetCommentsFromLocal</code></p>
            <pre><code>java.lang.AssertionError: Unexpected onError events: 1

	at rx.observers.TestSubscriber.assertNoErrors(TestSubscriber.java:308)
	at com.example.androidtdd.data.PlaceHolderRepositoryImplTest.testGetCommentsFromServer(PlaceHolderRepositoryImplTest.java:53)
	.....
Caused by: java.lang.Throwable
	at com.example.androidtdd.data.PlaceHolderRepositoryImplTest.testGetCommentsFromServer(PlaceHolderRepositoryImplTest.java:48)</code></pre>

            <code>PlaceHolderRepositoryImplTest.java:48</code> is
            <pre><code>when(mMockLocalDataSource.getComments(USER_ID))
    .thenReturn(Observable.error(new Throwable()));</code></pre>
            <p>We ignore all errors come from local data source</p>
            <pre><code>@Override
public Observable&lt;List&lt;Comment&gt;&gt; getComments(int userId) {
    return Observable.concat(mLocalDataSource.getComments(userId)
                    .onErrorReturn(error -> null),
            mRemoteDataSource.getComments(userId));
}</code></pre>
            <p>And run again</p>
            <p><img fsrc="img/test-fail.png" class="test-result"><code>PlaceHolderRepositoryImpl</code></p>
            <p><img fsrc="img/test-fail.png" class="test-result level-1"><code>testGetCommentsFromServer</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testGetCommentsFromLocal</code></p>
            <pre><code>java.lang.AssertionError: Number of items does not match. Provided: 1  Actual: 2.
Provided values: [[com.example.androidtdd.data.model.Comment@365185bd, com.example.androidtdd.data.model.Comment@18bf3d14, com.example.androidtdd.data.model.Comment@4fb64261, com.example.androidtdd.data.model.Comment@42607a4f, com.example.androidtdd.data.model.Comment@782663d3, com.example.androidtdd.data.model.Comment@1990a65e]]
Actual values: [null, [com.example.androidtdd.data.model.Comment@365185bd, com.example.androidtdd.data.model.Comment@18bf3d14, com.example.androidtdd.data.model.Comment@4fb64261, com.example.androidtdd.data.model.Comment@42607a4f, com.example.androidtdd.data.model.Comment@782663d3, com.example.androidtdd.data.model.Comment@1990a65e]]
 (1 completion)</code></pre>
            <p>We will take the first emmited result from local and remote which is not null, and it's not empty.</p>
            <pre><code>return Observable.concat(mLocalDataSource.getComments(userId)
            .onErrorReturn(error -> null),
    mRemoteDataSource.getComments(userId))
        .first(comments -> comments != null && comments.size() > 0);</code></pre>
            <p><img fsrc="img/test-ok.png" class="test-result"><code>PlaceHolderRepositoryImpl</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testGetCommentsFromServer</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testGetCommentsFromLocal</code></p>
            <p>Good, now we move to the last step, save comment if it comes from remote</p>
            <pre><code>@Test
    public void testSaveCommentsComeFromServer() throws Exception {
        List&lt;Comment> comments = DataFactory.makeComments(USER_ID);
        when(mMockLocalDataSource.getComments(USER_ID))
                .thenReturn(Observable.error(new Throwable()));
        when(mMockRemoteDataSource.getComments(USER_ID))
                .thenReturn(Observable.just(comments));
        mRepository.getComments(USER_ID).subscribe(commentTestSubscriber);
        verify(mMockRemoteDataSource).getComments(USER_ID);
        verify(mMockLocalDataSource).saveComment(comments, USER_ID);
        commentTestSubscriber.assertNoErrors();
        commentTestSubscriber.assertCompleted();
        commentTestSubscriber.assertValue(comments);
    }</code></pre>
            <p>We will have these output:</p>
            <p><img fsrc="img/test-fail.png" class="test-result"><code>PlaceHolderRepositoryImpl</code></p>
            <p><img fsrc="img/test-fail.png" class="test-result level-1"><code>testSaveCommentsComeFromServer</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testGetCommentsFromServer</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testGetCommentsFromLocal</code></p>
            <pre><code>Wanted but not invoked:
mMockLocalDataSource.saveComment(
    [com.example.androidtdd.data.model.Comment@4cf4d528],
    10
);</code></pre>
            <p>We will save comment by using <code>doOnNext()</code></p>
            <pre><code>return Observable.concat(mLocalDataSource.getComments(userId)
                        .onErrorReturn(error -> null),
                mRemoteDataSource.getComments(userId)
                        .doOnNext(comments -> mLocalDataSource.saveComment(comments, userId)))
                .first(comments -> comments != null && comments.size() > 0);</code></pre>
            <p>And run our test again</p>
            <p><img fsrc="img/test-ok.png" class="test-result"><code>PlaceHolderRepositoryImpl</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testSaveCommentsComeFromServer</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testGetCommentsFromServer</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testGetCommentsFromLocal</code></p>
            <p>Similar to <code>getComments</code>, <code>getPhotos</code> will be like this:</p>
            <code>PlaceHolderRepositoryImplTest</code>
            <pre><code>     @Test
    public void testGetPhotosFromServer() throws Exception {
        List&lt;Photo> photos = DataFactory.makePhotos(USER_ID);
        when(mMockLocalDataSource.getPhotos(USER_ID))
                .thenReturn(Observable.error(new Throwable()));
        when(mMockRemoteDataSource.getPhotos(USER_ID))
                .thenReturn(Observable.just(photos));
        mRepository.getPhotos(USER_ID).subscribe(photoTestSubscriber);
        verify(mMockRemoteDataSource).getPhotos(USER_ID);
        photoTestSubscriber.assertNoErrors();
        photoTestSubscriber.assertCompleted();
        photoTestSubscriber.assertValue(photos);
    }

    @Test
    public void testGetPhotosFromLocal() throws Exception {
        List&lt;Photo> photos = DataFactory.makePhotos(USER_ID);
        when(mMockLocalDataSource.getPhotos(USER_ID))
                .thenReturn(Observable.just(photos));
        when(mMockRemoteDataSource.getPhotos(USER_ID))
                .thenReturn(Observable.empty());
        mRepository.getPhotos(USER_ID).subscribe(photoTestSubscriber);
        verify(mMockLocalDataSource).getPhotos(USER_ID);
        photoTestSubscriber.assertNoErrors();
        photoTestSubscriber.assertCompleted();
        photoTestSubscriber.assertValue(photos);
    }

    @Test
    public void testSavePhotosComeFromServer() throws Exception {
        List&lt;Photo> photos = DataFactory.makePhotos(USER_ID);
        when(mMockLocalDataSource.getPhotos(USER_ID))
                .thenReturn(Observable.error(new Throwable()));
        when(mMockRemoteDataSource.getPhotos(USER_ID))
                .thenReturn(Observable.just(photos));
        mRepository.getPhotos(USER_ID).subscribe(photoTestSubscriber);
        verify(mMockRemoteDataSource).getPhotos(USER_ID);
        verify(mMockLocalDataSource).savePhotos(photos, USER_ID);
        photoTestSubscriber.assertNoErrors();
        photoTestSubscriber.assertCompleted();
        photoTestSubscriber.assertValue(photos);
    }</code></pre>
            <code>PlaceHolderRepositoryImpl</code>
            <pre><code>@Override
public Observable&lt;List&lt;Photo&gt;&gt; getPhotos(int userId) {
    return Observable.concat(mLocalDataSource.getPhotos(userId)
                    .onErrorReturn(error -> null),
            mRemoteDataSource.getPhotos(userId)
                    .doOnNext(photos -> mLocalDataSource.savePhotos(photos, userId)))
            .first(photos -> photos != null && photos.size() > 0);
}</code></pre>
            <p>The last and the easiest one:</p>
            <code>PlaceHolderRepositoryImplTest</code>
            <pre><code>@Test
public void testGetUsers() throws Exception {
    when(mPlaceHolderRepository.getUsers())
                .thenReturn(Observable.just(MockHelper.getUsers()));
    mPlaceHolderRepository.getUsers().subscribe(usersTestSubscriber);
    verify(mMockRemoteDataSource, times(1)).getUsers();
    usersTestSubscriber.assertCompleted();
    usersTestSubscriber.assertValue(MockHelper.getUsers());
    usersTestSubscriber.assertNoErrors();
}</code></pre>
            <code>PlaceHolderRepositoryImpl</code>
            <pre><code>@Override
public Observable&lt;List&lt;User&gt;&gt; getUsers() {
    return mRemoteDataSource.getUsers();
}</code></pre>
        </google-codelab-step>
        <google-codelab-step label="UI Package">
            <code>ui</code> package has the following subpackage
            <table>
                <tbody>
                    <tr>
                        <td colspan="2" rowspan="1">
                            <p><strong>Package: </strong><code>com.example.androidtdd</code></p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>.ui.base</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>"Base": Base package to implement MVP</p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>.ui.home</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>"home": Showing a list of all users</p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>.ui.detail</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>Detail: Show more about user's information.</p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>.ui.comment</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>Showing a list of comments from a specific user.</p>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="1" rowspan="1">
                            <p><code>.ui.photo</code></p>
                        </td>
                        <td colspan="1" rowspan="1">
                            <p>Showing a list of photos from a specific user.</p>
                        </td>
                    </tr>
                </tbody>
            </table>
            <p>We'll use MVP for this project, these are base classes under
                <code>ui.base</code>
            </p>
            <code>BaseActivity</code>
            <pre><code>public class BaseActivity extends AppCompatActivity {
    private ActivityComponent mActivityComponent;

    public ActivityComponent getActivityComponent() {
        if (mActivityComponent == null) {
            mActivityComponent = DaggerActivityComponent.builder()
                    .applicationComponent(PlaceHolderApplication.get(this).getComponent())
                    .build();
        }
        return mActivityComponent;
    }
}</code></pre>
            <code>BaseMvpView</code>
            <pre><code>public interface BaseMvpView {
    void showLoading();

    void hideLoading();

    void showError(String message);

    void showEmpty();
}
</code></pre>
            <code>BasePresenter</code>
            <pre><code>public class BasePresenter<V extends MvpView> implements Presenter<V> {
    private V view;

    @Override
    public void attachView(V v) {
        this.view = v;
    }

    @Override
    public void detachView() {
        this.view = null;
    }

    public V getView() {
        return view;
    }
}
</code></pre>
            <code>MvpView</code>
            <pre><code>public interface MvpView {
}</code></pre>
            <code>Presenter</code>
            <pre><code>public interface Presenter<V extends MvpView> {
    void attachView(V v);

    void detachView();
}</code></pre>
            <p>Let's get started with <code>HomePresenter</code></p>
            <code>HomePresenter</code>
            <pre><code>public class HomePresenter extends BasePresenter<HomeMvpView> {
    private PlaceHolderRepository mInnovatubeRepository;
    private Subscription mSubscription;

    @Inject
    public HomePresenter(PlaceHolderRepository mInnovatubeRepository) {
        this.mInnovatubeRepository = mInnovatubeRepository;
    }

    public void getUsers() {
        
    }

    public void showDetail(User user) {
        getView().viewDetail(user);
    }

    @Override
    public void detachView() {
        mSubscription.unsubscribe();
    }
}</code></pre>
            <p>We'll create a test class for <code>HomePresenter</code></p>
            <code>HomePresenterTest</code>
            <pre><code>@RunWith(MockitoJUnitRunner.class)
public class HomePresenterTest {
    @Mock
    HomeMvpView mMockHomeMvpView;
    private HomePresenter mHomePresenter;
    @Mock
    PlaceHolderRepository mMockRepository;

    @Rule
    public final RxSchedulerOverrideRule rule = new RxSchedulerOverrideRule();

    @Before
    public void setUp() throws Exception {
        mHomePresenter = new HomePresenter(mMockRepository);
        mHomePresenter.attachView(mMockHomeMvpView);
    }

    @Test
    public void testGetUsersSuccess() throws Exception {

    }
    

    @After
    public void tearDown() throws Exception {
        mHomePresenter.detachView();
    }
}</code></pre>
            <p><code>getUsers</code>'s strategy:</p>
            <ol>
                <li>show loading view.</li>
                <li>get users from repository.</li>
                <li>if users are sucessfully retreived, hide loading view and show users.</li>
                <li>if any errors occur, hide loading view and show error with message comes from <code>throwable</code>.</li>
            </ol>
            <code>HomePresenterTest</code>
            <pre><code>@Test
public void testGetUsersSuccess() throws Exception {
    List&lt;User> users = DataFactory.makeUsers();
    when(mMockRepository.getUsers()).thenReturn(Observable.just(users));
    mHomePresenter.getUsers();
    verify(mMockHomeMvpView).showLoading();
    verify(mMockHomeMvpView).hideLoading();
    verify(mMockHomeMvpView, times(0)).showError(anyString());
    verify(mMockHomeMvpView).showUsers(users);
}</code></pre>
            <p>Output for <code>testGetUsersSuccess</code> will look like this:</p>
            <p><img fsrc="img/test-fail.png" class="test-result"><code>HomePresenterTest</code></p>
            <p><img fsrc="img/test-fail.png" class="test-result level-1"><code>testGetUsersSuccess</code></p>
            <pre><code>Wanted but not invoked:
mMockHomeMvpView.showLoading();
-> at com.example.androidtdd.ui.home.HomePresenterTest.testGetUsersSuccess(HomePresenterTest.java:50)
Actually, there were zero interactions with this mock.</code></pre>
            <p>Now, we'll implement <code>getUsers</code></p>
            <pre><code>public void getUsers() {
    getMvpView().showLoading();
    mSubscription = mInnovatubeRepository.getUsers()
            .subscribeOn(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(users -> {
                getMvpView().hideLoading();
                getMvpView().showUsers(users);
            }, error -> {
                    
            });
}</code></pre>
            <p>And run again:</p>
            <p><img fsrc="img/test-ok.png" class="test-result"><code>HomePresenterTest</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testGetUsersSuccess</code></p>
            <code>testGetUsersFailed</code>
            <pre><code>@Test
public void testGetUsersFailed() throws Exception {
    String message = "Unknow Error";
    when(mMockRepository.getUsers()).thenReturn(Observable.error(new Throwable(message)));
    mHomePresenter.getUsers();
    verify(mMockHomeMvpView).showLoading();
    verify(mMockHomeMvpView).hideLoading();
    verify(mMockHomeMvpView).showError(message);
    verify(mMockHomeMvpView, times(0)).showUsers(any(List.class));
    verify(mMockHomeMvpView).showEmpty();
}</code></pre>
            <p><img fsrc="img/test-fail.png" class="test-result"><code>HomePresenterTest</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testGetUsersSuccess</code></p>
            <p><img fsrc="img/test-fail.png" class="test-result level-1"><code>testGetUsersFailed</code></p>
            <p>Now , we must implement <code>getUsers</code> to cover the error.</p>
            <pre><code>public void getUsers() {
    getMvpView().showLoading();
    mSubscription = mInnovatubeRepository.getUsers()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(users -> {
                    getMvpView().hideLoading();
                    getMvpView().showUsers(users);
                }, error -> {
                    getMvpView().hideLoading();
                    getMvpView().showError(error.getMessage());
                });
}</code></pre>
            <p><img fsrc="img/test-ok.png" class="test-result"><code>HomePresenterTest</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testGetUsersSuccess</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testGetUsersFailed</code></p>
            <p>All is green, now we move to the last one <code>showDetail</code></p>

            <code>HomePresenterTest</code>
            <pre><code>@Test
public void testViewDetail() throws Exception {
    int userId = 1;
    User user = DataFactory.makeUser(userId);
    mHomePresenter.showDetail(user);
    verify(mMockHomeMvpView).viewDetail(user);
}</code></pre>
            <code>HomePresenter</code>
            <pre><code>public void showDetail(User user) {
    getMvpView().viewDetail(user);
}
</code></pre>
            <p><img fsrc="img/test-ok.png" class="test-result"><code>HomePresenterTest</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testGetUsersSuccess</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testGetUsersFailed</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testViewDetail</code></p>
            <p><code>CommentPresenter</code>,<code>DetailPresenter</code> and <code>PhotoPresenter</code> are similar to <code>HomePresenter</code></p>
        </google-codelab-step>
        <google-codelab-step label="UI Testing">
            <img fsrc="img/home-outline.png" />
            <p>Home consisted of the following elements</p>
            <ol>
                <li><code>RecyclerView</code> with id :<code>R.id.recycler_users</code></li>
                <li><code>LinearLayout</code> contains user's info.</li>
                <li><code>TextView</code> presents name, wih id <code>R.id.text_name</code></li>
                <li><code>TextView</code> presents email, wih id <code>R.id.text_email</code></li>
                <li><code>TextView</code> presents phone number, wih id <code>R.id.text_phone</code></li>
                <li><code>TextView</code> presents website, wih id <code>R.id.text_website</code></li>
                <li><code>TextView</code> presents loading indicator, wih id <code>R.id.text_loading</code></li>
                <li><code>TextView</code> presents emptyview, wih id <code>R.id.text_empty</code></li>
            </ol>
            <p>Every users taken from repository will be shown on RecyclerView, this is our first test</p>
            <p>Add the following dependencies to <code>build.gradle</code></p>
            <pre><code>androidTestCompile("com.android.support.test.espresso:espresso-core:${espressoVersion}", {
        exclude group: 'com.android.support', module: 'support-annotations'
})
androidTestCompile "com.github.fabioCollini:DaggerMock:${daggerMockVersion}"
androidTestCompile "com.google.dexmaker:dexmaker:${dexMakerVersion}"
androidTestCompile "com.google.dexmaker:dexmaker-mockito:${dexMakerVersion}"

androidTestCompile ("com.android.support.test:rules:${androidSupportTestRunner}",{
    exclude group: 'com.android.support', module: 'support-annotations'
})
androidTestCompile("com.android.support.test:runner:${androidSupportTestRunner}", {
    exclude group: 'com.android.support', module: 'support-annotations'
})
androidTestCompile("com.android.support.test.espresso:espresso-contrib:${espressoVersion}", {
    exclude group: 'com.android.support'
})</code></pre>
            <p>And <code>PlaceHolderApplication</code></p>
            <pre><code>@VisibleForTesting
public void setApplicationComponent(ApplicationComponent mApplicationComponent) {
    this.mApplicationComponent = mApplicationComponent;
}</code></pre>
            <p>To simplify our project, we'll use <code>CountingIdlingResource</code>.</p>
            <code>SimpleCountingIdlingResource</code>
            <pre><code>public final class SimpleCountingIdlingResource implements IdlingResource {

    private final String mResourceName;

    private final AtomicInteger counter = new AtomicInteger(0);

    // written from main thread, read from any thread.
    private volatile ResourceCallback resourceCallback;

    /**
     * Creates a SimpleCountingIdlingResource
     *
     * @param resourceName the resource name this resource should report to Espresso.
     */
    public SimpleCountingIdlingResource(String resourceName) {
        mResourceName = resourceName;
    }

    @Override
    public String getName() {
        return mResourceName;
    }

    @Override
    public boolean isIdleNow() {
        return counter.get() == 0;
    }

    @Override
    public void registerIdleTransitionCallback(ResourceCallback resourceCallback) {
        this.resourceCallback = resourceCallback;
    }

    /**
     * Increments the count of in-flight transactions to the resource being monitored.
     */
    public void increment() {
        counter.getAndIncrement();
    }

    /**
     * Decrements the count of in-flight transactions to the resource being monitored.
     * &lt;p&gt;
     * If this operation results in the counter falling below 0 - an exception is raised.
     *
     * @throws IllegalStateException if the counter is below 0.
     */
    public void decrement() {
        int counterVal = counter.decrementAndGet();
        if (counterVal == 0) {
            // we've gone from non-zero to zero. That means we're idle now! Tell espresso.
            if (null != resourceCallback) {
                resourceCallback.onTransitionToIdle();
            }
        }

        if (counterVal < 0) {
            throw new IllegalArgumentException("Counter has been corrupted!");
        }
    }
}
</code></pre>
            <code>EspressoIdlingResource</code>
            <pre><code>public class EspressoIdlingResource {
    private static final String RESOURCE_NAME = "Innovatube";

    private static SimpleCountingIdlingResource mCountingIdlingResource =
            new SimpleCountingIdlingResource(RESOURCE_NAME);

    public static void increment() {
        mCountingIdlingResource.increment();
    }

    public static void decrement() {
        mCountingIdlingResource.decrement();
    }

    public static IdlingResource getIdlingResource() {
        return mCountingIdlingResource;
    }
}</code></pre>
            <code>HomePresenter</code>
            <pre><code>public class HomePresenter extends BasePresenter<HomeMvpView> {
    ...

    public void getUsers() {
        getMvpView().showLoading();
        EspressoIdlingResource.increment();
        mSubscription = mPlaceHolderRepository.getUsers()
                .subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(users -> {
                    EspressoIdlingResource.decrement();
                    getMvpView().hideLoading();
                    getMvpView().showUsers(users);
                    if (users == null || users.size() == 0) {
                        getMvpView().showEmpty();
                    } else {
                        getMvpView().showUsers(users);
                    }
                }, error -> {
                    EspressoIdlingResource.decrement();
                    getMvpView().hideLoading();
                    getMvpView().showEmpty();
                    getMvpView().showError(error.getMessage());
                });
    }
    ...
}</code></pre>
            <p>Since we want to test loading text too, so we must register <i>IdlingResource</i> in test method instead of <code>setUp()</code></p>
            <pre><code>@RunWith(AndroidJUnit4.class)
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class HomeActivityTest {
    @Rule
    public IntentsTestRule mActivityTestRule = new IntentsTestRule(HomeActivity.class, true, false);
    private MockWebServer server;
                
    @Before
    public void setUp() throws Exception {
        server = new MockWebServer();
        server.start(1212);
        Constants.ENDPOINT = server.url("/").toString();
    }

    @Test
    public void testGetUsersAndDisplayData() throws Exception {
        String usersInput = MockHelper.readUsersString();
        server.enqueue(new MockResponse()
                .setResponseCode(200)
                .setBody(usersInput)
                .setBodyDelay(2000, TimeUnit.MILLISECONDS));
        List<User> users = MockHelper.getUsers(usersInput, new Gson());
        mActivityTestRule.launchActivity(null);
        onView(withId(R.id.text_loading)).check(matches(isDisplayed()));
        Espresso.registerIdlingResources(EspressoIdlingResource.getIdlingResource());
        onView(withId(R.id.text_loading)).check(matches(not(isDisplayed())));
        RecyclerViewInteraction.&lt;User&gt;onRecyclerView(withId(R.id.recycler_users))
                .withItems(users)
                .check((item, view, e) -&gt; matches(allOf(hasDescendant(withText(item.getName())),
                        hasDescendant(withText(item.getPhone())),
                        hasDescendant(withText(item.getEmail())),
                        hasDescendant(withText(item.getWebsite())))).check(view, e));
        Espresso.unregisterIdlingResources(EspressoIdlingResource.getIdlingResource());
    }
    
    @After
    public void tearDown() throws Exception {
        server.shutdown();
    }
}</code></pre>
            <p>We're using Toast to display error message, so the error test case will be the last to test.</p>
            <p>We use <i>dexmaker</i> and <i>DaggerMock</i> to mock our dependencies. Since we haven't implemented <code>HomeActivity</code>,<code>testGetUsersAndDisplayData</code> will fail.</p>
            <pre><code>android.support.test.espresso.base.DefaultFailureHandler$AssertionFailedWithCauseError: 'is displayed on the screen to the user' doesn't match the selected view.
Expected: is displayed on the screen to the user
Got: "AppCompatTextView{id=2131558519, res-name=text_loading, visibility=GONE, width=0, height=0, has-focus=false, has-focusable=false, has-window-focus=true, is-clickable=false, is-enabled=true, is-focused=false, is-focusable=false, is-layout-requested=true, is-selected=false, root-is-layout-requested=false, has-input-connection=false, x=0.0, y=0.0, text=Loading, input-type=0, ime-target=false, has-links=false}"</code></pre>
            <p>Let's get started with <code>showLoading()</code>, <code>hideLoading()</code> and <code>showUsers()</code>.</p>
            <pre><code>
public class HomeActivity extends BaseActivity implements HomeMvpView {
    @Inject
    HomePresenter mHomePresenter;
    @BindView(R.id.recycler_users)
    RecyclerView mUserRecycler;
    @BindView(R.id.text_loading)
    TextView mLoadingTextView;
    private UserAdapter mAdapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_home);
        ButterKnife.bind(this);
        getActivityComponent().inject(this);
        mHomePresenter.attachView(this);
        mHomePresenter.getUsers();
        mAdapter = new UserAdapter();
        mUserRecycler.setAdapter(mAdapter);
        mUserRecycler.setLayoutManager(new LinearLayoutManager(this));
    }
    @Override
    public void showLoading() {
        mLoadingTextView.setVisibility(View.VISIBLE);
        mUserRecycler.setVisibility(View.GONE);
        mEmptyTextView.setVisibility(View.GONE);
    }

    @Override
    public void hideLoading() {
        mLoadingTextView.setVisibility(View.GONE);
    }
    @Override
    public void showUsers(List&lt;User> users) {
        
    }
    ...
    
}</code></pre>
            <code>UserAdapter</code> is:
            <pre><code>public class UserAdapter extends RecyclerView.Adapter<UserAdapter.UserHolder> {
    private List&lt;User> users;

    public UserAdapter() {
        users = new ArrayList&lt;>();
    }

    public void setUsers(List&lt;User> users) {
        this.users = users;
        notifyItemRangeInserted(0, users.size());
    }

    @Override
    public UserHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.item_user, parent, false);
        return new UserHolder(view);
    }

    @Override
    public void onBindViewHolder(UserHolder holder, int position) {
        
    }

    @Override
    public int getItemCount() {
        return users.size();
    }

    public class UserHolder extends RecyclerView.ViewHolder {
        @BindView(R.id.text_name)
        TextView mNameTextView;
        @BindView(R.id.text_phone)
        TextView mPhoneTextView;
        @BindView(R.id.text_website)
        TextView mWebsiteTextView;
        @BindView(R.id.text_email)
        TextView mEmailTextView;

        public UserHolder(View itemView) {
            super(itemView);
            ButterKnife.bind(this, itemView);
        }
    }
}
</code></pre>
            <code>R.layout.item_user</code>
            <pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:orientation=&quot;vertical&quot;
    android:paddingBottom=&quot;2dp&quot;&gt;

    &lt;TextView
        android:id=&quot;@+id/text_name&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        tools:text=&quot;Name&quot; /&gt;

    &lt;TextView
        android:id=&quot;@+id/text_email&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        tools:text=&quot;example@example.com&quot; /&gt;

    &lt;TextView
        android:id=&quot;@+id/text_phone&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        tools:text=&quot;+84167232323&quot; /&gt;

    &lt;TextView
        android:id=&quot;@+id/text_website&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        tools:text=&quot;www.example.com&quot; /&gt;
&lt;/LinearLayout&gt;</code></pre>
            <p>Then run <code>testGetUsersAndDisplayData</code> again:</p>
            <p><img fsrc="img/test-fail.png" class="test-result"><code>HomeActivityTest</code></p>
            <p><img fsrc="img/test-fail.png" class="test-result level-1"><code>testGetUsersAndDisplayData</code></p>
            <pre> <code>android.support.test.espresso.base.DefaultFailureHandler$AssertionFailedWithCauseError: 'has descendant: with text: is "72e950a3-76e7-4c08-b453-3c1da232f7bb"' doesn't match the selected view.
Expected: has descendant: with text: is "72e950a3-76e7-4c08-b453-3c1da232f7bb"
Got: "LinearLayout{id=-1, visibility=VISIBLE, width=704, height=156, has-focus=false, has-focusable=false, has-window-focus=true, is-clickable=false, is-enabled=true, is-focused=false, is-focusable=false, is-layout-requested=false, is-selected=false, root-is-layout-requested=false, has-input-connection=false, x=0.0, y=0.0, child-count=4}"
.</code></pre>
            <p>Now we must implement <code>UserAdapter</code></p>
            <pre><code>public class UserAdapter extends RecyclerView.Adapter<UserAdapter.UserHolder> {
    private List&lt;User> users;

   ....

    @Override
    public void onBindViewHolder(UserHolder holder, int position) {
        holder.mNameTextView.setText(users.get(position).getName());
        holder.mEmailTextView.setText(users.get(position).getEmail());
        holder.mPhoneTextView.setText(users.get(position).getPhone());
        holder.mWebsiteTextView.setText(users.get(position).getWebsite());
    }

    @Override
    public int getItemCount() {
        return users.size();
    }

    ...
}
</code></pre>
            <p><img fsrc="img/test-ok.png" class="test-result"><code>HomeActivityTest</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testGetUsersAndDisplayData</code></p>
            <p>It's green now, we'll move to the next one</p>
            <code>HomeActivityTest</code>
            <pre><code>
@RunWith(AndroidJUnit4.class)
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class HomeActivityTest {
    ...
    @Test
    public void testGetUsersAndDisplayError() throws Exception {
        String message = "HTTP 404 Client Error";
        server.enqueue(new MockResponse()
                .setResponseCode(404)
                .setBody("blah blah")
                .setBodyDelay(1000, TimeUnit.MILLISECONDS));
        mActivityTestRule.launchActivity(null);
        onView(withId(R.id.text_loading)).check(matches(isDisplayed()));
        Espresso.registerIdlingResources(EspressoIdlingResource.getIdlingResource());
        onView(withId(R.id.text_loading)).check(matches(not(isDisplayed())));
        Activity activity = mActivityTestRule.getActivity();
        onView(withId(R.id.text_empty)).check(matches(isDisplayed()));
        onView(withText(message)).inRoot(withDecorView(not(is(activity.getWindow().getDecorView()))))
                .check(matches(isDisplayed()));
        Espresso.unregisterIdlingResources(EspressoIdlingResource.getIdlingResource());
    }
}</code></pre>
            <p><img fsrc="img/test-fail.png" class="test-result"><code>HomeActivityTest</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testGetUsersAndDisplayData</code></p>
            <p><img fsrc="img/test-fail.png" class="test-result level-1"><code>testGetUsersAndDisplayError</code></p>
            <pre><code>
android.support.test.espresso.NoMatchingRootException: Matcher 'with decor view not is <DecorView@39d7d43[HomeActivity]>' did not match any of the following roots: [Root{application-window-token=android.view.ViewRootImpl$W@b0aefc0, window-token=android.view.ViewRootImpl$W@b0aefc0, has-window-focus=true, layout-params-type=1, layout-params-string=WM.LayoutParams{(0,0)(fillxfill) ty=1 fl=#81810100 pfl=0x20000 wanim=0x1030468 needsMenuKey=2}, decor-view-string=DecorView{id=-1, visibility=VISIBLE, width=768, height=1280, has-focus=false, has-focusable=true, has-window-focus=true, is-clickable=false, is-enabled=true, is-focused=false, is-focusable=false, is-layout-requested=false, is-selected=false, root-is-layout-requested=false, has-input-connection=false, x=0.0, y=0.0, child-count=3}}]
at dalvik.system.VMStack.getThreadStackTrace(Native Method)</code></pre>
            <p>Turning out we haven't implemented <code>showError()</code> yet.</p>
            <pre><code>@Override
public void showError(String message) {
    Toast.makeText(this, message, Toast.LENGTH_SHORT).show();
}</code></pre>
            <p>Then run again</p>
            <p><img fsrc="img/test-ok.png" class="test-result"><code>HomeActivityTest</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testGetUsersAndDisplayData</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testGetUsersAndDisplayError</code></p>
            <p>The last one for <code>HomeActivity</code> is click on user will navigate to <code>DetailActivity</code>.</p>
            <p>We'll use espresso-intents for <code>viewDetail</code> </p>
            <code>build.gradle</code>
            <pre><code>androidTestCompile("com.android.support.test.espresso:espresso-intents:${espressoVersion}", {
        exclude group: 'com.android.support'
    })</code></pre>
            <code>HomeActivityTest</code>
            <pre><code>@RunWith(AndroidJUnit4.class)
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class HomeActivityTest {
    @Rule
    public ActivityTestRule mActivityTestRule = new ActivityTestRule(HomeActivity.class, true, false);
...
    @Test
    public void testClickOnUserNavigateToDetail() throws Exception {
        Espresso.registerIdlingResources(EspressoIdlingResource.getIdlingResource());
        String usersInput = MockHelper.readUsersString();
        server.enqueue(new MockResponse()
                .setResponseCode(200)
                .setBody(usersInput)
                .setBodyDelay(0, TimeUnit.MILLISECONDS));
        List&lt;User&gt; users = MockHelper.getUsers(usersInput, new Gson());
        mActivityTestRule.launchActivity(null);
        onView(withId(R.id.recycler_users))
                .perform(RecyclerViewActions.actionOnItemAtPosition(0, click()));
        intended(allOf(IntentMatchers.toPackage("com.example.androidtdd"),
                IntentMatchers.hasExtra(DetailActivity.ARG_USER, users.get(0))));
        Espresso.unregisterIdlingResources(EspressoIdlingResource.getIdlingResource());
    }
}</code></pre>
            <code>console</code>
            <pre><code>android.support.test.espresso.base.DefaultFailureHandler$AssertionFailedWithCauseError: Wanted to match 1 intents. Actually matched 0 intents.
IntentMatcher: (resolvesTo: com.example.androidtdd.ui and has extras: has bundle with: key: is "SELECTED_USER" value: is <com.example.androidtdd.data.model.User@925a6de>)
Matched intents:[]
Recorded intents:[]</code></pre>
            <p>Now we'll implement this feature.</p>
            <code>util.UserListener</code>
            <pre><code>public interface UserListener {
    void onUserClick(User user);
}</code></pre>
            <code>HomeActivity</code>
            <pre><code>public class HomeActivity extends BaseActivity implements HomeMvpView,UserListener {
    ...
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...
        mAdapter = new UserAdapter(this);
        ...
    }
    @Override
    public void onUserClick(User user) {
        mHomePresenter.showDetail(user);
    }
}</code></pre>
            <code>UserAdapter</code>
            <pre><code>public class UserAdapter extends RecyclerView.Adapter<UserAdapter.UserHolder> {
    ...
    private UserListener mListener;
    public UserAdapter(UserListener listener) {
        users = new ArrayList&lt;>();
        mListener = listener;
    }
    @Override
    public void onBindViewHolder(UserHolder holder, int position) {
        ...
        holder.itemView.setOnClickListener(view->mListener.onUserClick(users.get(position)));
    }
}
</code></pre>
            <p>Great, it's green now</p>
            <p><img fsrc="img/test-ok.png" class="test-result"><code>HomeActivityTest</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testGetUsersAndDisplayData</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testGetUsersAndDisplayError</code></p>
            <p><img fsrc="img/test-ok.png" class="test-result level-1"><code>testClickOnUserNavigateToDetail</code></p>
            <p><strong>Now, it's your time to practice, implememt <code>DetailActivity</code>, <code>CommentActivity</code> and <code>PhotoActivity</code></strong></p>
            <p><i>Because we're mocking repository, you may want to mock <code>getPhotos</code> and <code>getComments</code> in <code>DetailActivityTest</code>.</i></p>
        </google-codelab-step>
        <google-codelab-step label="Source code">
            <aside class="special">
                <p>You can download the source code for this tutorial from here</p>
                <a href="https://github.com/Innovatube/android-tdd-approach/archive/master.zip">Download</a>
            </aside>
        </google-codelab-step>
    </google-codelab>


</body>

</html>